name: Deploy Number Acidizer Full Stack

on:
  push:
    branches: [main, dev]
  pull_request:
    branches: [main, dev]

env:
  AWS_REGION: us-east-1

jobs:
  test-backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Test backend
        working-directory: ./backend
        run: |
          npm ci
          npm run build
          npm run lint
          npm test

  test-frontend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Test frontend
        working-directory: ./frontend
        run: |
          npm ci
          npm run lint
          # npm test  # Add unit tests here if you have them

  deploy:
    runs-on: ubuntu-latest
    needs: [test-backend, test-frontend]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev')

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Set environment
        id: set-env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "ecr_repo=acidizer-backend" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "ecr_repo=acidizer-backend-dev" >> $GITHUB_OUTPUT
          fi

      - name: Build and push backend
        working-directory: ./backend
        env:
          ECR_REPO: ${{ steps.set-env.outputs.ecr_repo }}
        run: |
          # Create ECR repo if needed
          aws ecr describe-repositories --repository-names $ECR_REPO || \
          aws ecr create-repository --repository-name $ECR_REPO

          # Login to ECR
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $(aws sts get-caller-identity --query Account --output text).dkr.ecr.$AWS_REGION.amazonaws.com

          # Build and push
          ECR_URI=$(aws sts get-caller-identity --query Account --output text).dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPO
          docker build -t $ECR_URI:latest .
          docker push $ECR_URI:latest

      - name: Deploy backend infrastructure
        working-directory: ./infrastructure
        run: |
          terraform init

          # Workspace isolation
          terraform workspace select ${{ steps.set-env.outputs.environment }} || terraform workspace new ${{ steps.set-env.outputs.environment }}

          # Create prerequisites manually (if needed)
          ENV=${{ steps.set-env.outputs.environment }}
          aws dynamodb create-table --table-name acidizer-$ENV-counter --attribute-definitions AttributeName=id,AttributeType=S --key-schema AttributeName=id,KeyType=HASH --billing-mode PAY_PER_REQUEST 2>/dev/null || true
          aws iam create-role --role-name acidizer-$ENV-lambda-role --assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"lambda.amazonaws.com"},"Action":"sts:AssumeRole"}]}' 2>/dev/null || true
          aws iam put-role-policy --role-name acidizer-$ENV-lambda-role --policy-name acidizer-$ENV-lambda-policy --policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Action":["logs:CreateLogGroup","logs:CreateLogStream","logs:PutLogEvents"],"Resource":"arn:aws:logs:*:*:*"},{"Effect":"Allow","Action":["dynamodb:GetItem","dynamodb:UpdateItem"],"Resource":"arn:aws:dynamodb:us-east-1:*:table/acidizer-'$ENV'-counter"}]}' 2>/dev/null || true

          # Import existing resources (ignore errors)
          terraform import aws_dynamodb_table.counter acidizer-$ENV-counter 2>/dev/null || true
          terraform import aws_iam_role.lambda_role acidizer-$ENV-lambda-role 2>/dev/null || true

          # Deploy infrastructure
          terraform apply -auto-approve \
            -var="lambda_image_uri=$(aws sts get-caller-identity --query Account --output text).dkr.ecr.$AWS_REGION.amazonaws.com/${{ steps.set-env.outputs.ecr_repo }}:latest" \
            -var="environment=${{ steps.set-env.outputs.environment }}"

      # Step 3: Get backend URL and build frontend
      - name: Build and deploy frontend
        working-directory: ./infrastructure
        run: |
          # Get the deployed API URL
          API_URL=$(terraform output -raw api_url)
          FRONTEND_BUCKET=$(terraform output -raw frontend_bucket)

          echo "üîó Backend API URL: $API_URL"
          echo "üì¶ Frontend bucket: $FRONTEND_BUCKET"

          # Build frontend with real API URL
          cd ../frontend
          export NEXT_PUBLIC_API_URL="$API_URL"

          echo "Building frontend with API_URL: $NEXT_PUBLIC_API_URL"
          npm ci
          npm run build

          # Deploy to S3
          aws s3 sync ./out/ s3://$FRONTEND_BUCKET --delete

          echo "‚úÖ Frontend deployed to S3: $FRONTEND_BUCKET"

      # Step 4: Invalidate CloudFront cache
      - name: Invalidate CloudFront cache
        working-directory: ./infrastructure
        run: |
          FRONTEND_BUCKET=$(terraform output -raw frontend_bucket)

          # Find CloudFront distribution for this bucket
          CLOUDFRONT_ID=$(aws cloudfront list-distributions --query "DistributionList.Items[?contains(Origins.Items[0].DomainName, '$FRONTEND_BUCKET')].Id" --output text)

          if [[ -n "$CLOUDFRONT_ID" && "$CLOUDFRONT_ID" != "None" ]]; then
            echo "‚ôªÔ∏è Invalidating CloudFront cache: $CLOUDFRONT_ID"
            aws cloudfront create-invalidation --distribution-id $CLOUDFRONT_ID --paths "/*"
          fi

      - name: Test deployment
        working-directory: ./infrastructure
        run: |
          API_URL=$(terraform output -raw api_url)
          FRONTEND_URL=$(terraform output -raw frontend_url)

          echo ""
          echo "üéâ DEPLOYMENT COMPLETE!"
          echo "üì° Environment: ${{ steps.set-env.outputs.environment }}"
          echo "üîó Backend URL: $API_URL"
          echo "üåç Frontend URL: $FRONTEND_URL"