name: Deploy Number Acidizer

on:
  push:
    branches: [main, dev]
  pull_request:
    branches: [main, dev]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: acidizer-backend

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Test backend
        working-directory: ./backend
        run: |
          npm ci
          npm run build
          npm run lint
          npm test

      - name: Test frontend
        working-directory: ./frontend
        run: |
          npm ci
          npm run build
          npm run lint

  deploy:
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev')

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Set environment based on branch
        id: set-env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "ecr_repo=acidizer-backend" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "ecr_repo=acidizer-backend-dev" >> $GITHUB_OUTPUT
          fi

      - name: Build and push Docker image
        working-directory: ./backend
        env:
          ECR_REPO: ${{ steps.set-env.outputs.ecr_repo }}
        run: |
          # Create ECR repo if needed
          aws ecr describe-repositories --repository-names $ECR_REPO || \
          aws ecr create-repository --repository-name $ECR_REPO

          # Login to ECR
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $(aws sts get-caller-identity --query Account --output text).dkr.ecr.$AWS_REGION.amazonaws.com

          # Build and push
          ECR_URI=$(aws sts get-caller-identity --query Account --output text).dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPO
          docker build -t $ECR_URI:latest .
          docker push $ECR_URI:latest

      - name: Setup AWS resources and imports
        working-directory: ./infrastructure
        env:
          TF_VAR_environment: ${{ steps.set-env.outputs.environment }}
        run: |
          terraform init

          # Create AWS resources first (without terraform)
          ENV=${{ steps.set-env.outputs.environment }}
          aws ecr create-repository --repository-name acidizer-$ENV-backend 2>/dev/null || true
          aws dynamodb create-table --table-name acidizer-$ENV-counter --attribute-definitions AttributeName=id,AttributeType=S --key-schema AttributeName=id,KeyType=HASH --billing-mode PAY_PER_REQUEST 2>/dev/null || true
          aws iam create-role --role-name acidizer-$ENV-lambda-role --assume-role-policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"lambda.amazonaws.com"},"Action":"sts:AssumeRole"}]}' 2>/dev/null || true
          aws iam put-role-policy --role-name acidizer-$ENV-lambda-role --policy-name acidizer-$ENV-lambda-policy --policy-document '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Action":["logs:CreateLogGroup","logs:CreateLogStream","logs:PutLogEvents"],"Resource":"arn:aws:logs:*:*:*"},{"Effect":"Allow","Action":["dynamodb:GetItem","dynamodb:UpdateItem"],"Resource":"arn:aws:dynamodb:us-east-1:*:table/acidizer-'$ENV'-counter"}]}' 2>/dev/null || true

          # Check if Lambda exists and delete it if so (force recreate)
          if aws lambda get-function --function-name acidizer-$ENV-backend 2>/dev/null; then
            echo "Lambda function exists, deleting to recreate..."
            aws lambda delete-function --function-name acidizer-$ENV-backend
            sleep 10
          fi

          # Import existing resources to terraform (except Lambda)
          terraform import aws_ecr_repository.backend acidizer-$ENV-backend 2>/dev/null || true
          terraform import aws_dynamodb_table.counter acidizer-$ENV-counter 2>/dev/null || true
          terraform import aws_iam_role.lambda_role acidizer-$ENV-lambda-role 2>/dev/null || true

      - name: Deploy backend infrastructure
        working-directory: ./infrastructure
        env:
          TF_VAR_environment: ${{ steps.set-env.outputs.environment }}
        run: |
          # Use workspace for environment isolation
          terraform init
          terraform workspace select ${{ steps.set-env.outputs.environment }} || terraform workspace new ${{ steps.set-env.outputs.environment }}

          terraform plan \
            -var="lambda_image_uri=$(aws sts get-caller-identity --query Account --output text).dkr.ecr.$AWS_REGION.amazonaws.com/${{ steps.set-env.outputs.ecr_repo }}:latest" \
            -var="environment=${{ steps.set-env.outputs.environment }}"

          terraform apply -auto-approve \
            -var="lambda_image_uri=$(aws sts get-caller-identity --query Account --output text).dkr.ecr.$AWS_REGION.amazonaws.com/${{ steps.set-env.outputs.ecr_repo }}:latest" \
            -var="environment=${{ steps.set-env.outputs.environment }}"

      # Frontend: Build with backend URL and deploy
      - name: Build and deploy frontend
        working-directory: ./frontend
        env:
          TF_WORKSPACE: ${{ steps.set-env.outputs.environment }}
        run: |
          # Get API URL from Terraform output
          cd ../infrastructure
          API_URL=$(terraform output -raw api_url)
          echo "üîó Backend API URL: $API_URL"

          # Get frontend bucket from Terraform output
          FRONTEND_BUCKET=$(terraform output -raw frontend_bucket)
          echo "üì¶ Frontend bucket: $FRONTEND_BUCKET"

          cd ../frontend

          # Build frontend with backend URL
          echo "NEXT_PUBLIC_API_URL=$API_URL" > .env.production
          npm ci
          npm run build

          # Deploy to S3
          aws s3 sync ./out/ s3://$FRONTEND_BUCKET --delete

          # Invalidate CloudFront cache
          cd ../infrastructure
          CLOUDFRONT_ID=$(aws cloudfront list-distributions --query "DistributionList.Items[?contains(Origins.Items[0].DomainName, '$FRONTEND_BUCKET')].Id" --output text)
          if [[ -n "$CLOUDFRONT_ID" ]]; then
            echo "‚ôªÔ∏è Invalidating CloudFront cache: $CLOUDFRONT_ID"
            aws cloudfront create-invalidation --distribution-id $CLOUDFRONT_ID --paths "/*"
          fi

      # Test: Verify deployment
      - name: Test deployment
        working-directory: ./infrastructure
        run: |
          # Wait for deployment to be ready
          sleep 30

          # Get URLs
          API_URL=$(terraform output -raw api_url)
          FRONTEND_URL=$(terraform output -raw frontend_url)

          echo "üåê API deployed at: $API_URL"
          echo "üåê Frontend deployed at: $FRONTEND_URL"

          # Test backend API
          echo "Testing backend API..."
          curl -f "$API_URL" || echo "‚ö†Ô∏è Backend API test failed (might be initializing)"

          # Test frontend (basic check)
          echo "Testing frontend..."
          curl -f "$FRONTEND_URL" || echo "‚ö†Ô∏è Frontend test failed (might be initializing)"

          echo "‚úÖ Full stack deployment completed!"
          echo "üì° Environment: ${{ steps.set-env.outputs.environment }}"
          echo "üîó Backend URL: $API_URL"
          echo "üåç Frontend URL: $FRONTEND_URL"